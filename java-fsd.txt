Day1    21-Jun-2021
====================
JDK 8
=====
https://www.oracle.com/java/technologies/javase/javase8-archive-downloads.html#license-lightbox


STS Download
============
https://dist.springsource.com/release/STS/3.9.11.RELEASE/dist/e4.14/spring-tool-suite-3.9.11.RELEASE-e4.14.0-win32-x86_64.zip

Spring Distrubution 5.0
=======================
https://repo.spring.io/release/org/springframework/spring/5.0.2.RELEASE/


Enterprise Application
=======================


Enterprise :(Business Organization) : make the money by providing services
===================================
Banks  :withdraw,deposit,fundTransfer,loan
LICS   :Insurance policy
Transports:book,cancel ticket
Hotels  :order food,book table
Hospitals:appointment
School   :admission,teaching,result
College  :admission,teaching,result


Layer :Logical separation of code
Tier  :Physical separation of code

Applications development platforms

Java
.Net
PHP
Node JS
Python



Database Operation
=====================
C=Create
R=Retrieve
U=Update
D=Delete


fundTransfer:(int source,int destination ,int amount)
             
             1.retireve source and validate amount < avialable
             2.retirve destination and validate 
             3.debit source -update
             4.credit destination -update
             5.commit


1.Presentation Layer :Code written to provide the input screen and resposne to the user
2.Service Layer      :Logical implementation of business rules
3.Data Access Layer  :Code written to access the data from Data source
4.Data Layer         :It is source for Data   


Three data sources
==================
Collection (List,Set,Map)
MySQL
MongoDB


Data Access Layer : Hibernate
Service Layer     : EJB
Presentation Layer :Struts

Spring -One stop shop application
        It takes care of all layers of enterprise application
         


Banking
=======

Develop a Banking application

Write a Java application to perform standard CRUD operations on Customer and Account Domain Objects using Map as DataSource.

    
     
Customer
        customerId
        name
        pan
        mobile         
        address
        dob
        

Account:
        accno
	name 
        balance
        String pan
        String adhar
        doc
        type

        
         
CustomerMainApp
              CustomerService
                           CustomerDao
                                        MapCustomerDaoImpl
                                                                CustomerMap
               


                                                    



Day1    22-Jun-2021
====================

Spring :  IOC ,DI via XML/Annotation


IOC -Inversion of Control -Don't call me I  will call you

DI  -It is a mechanism of initializing the dependencies 

      1.setter injection      :
      2.constructor injection :     
      
      
We have to explain Spring Container about the spring beans(Java Classes) via XML file or annotations


Step 1: create a Java Project and add spring jar files to class path


Step 2: create a spring container (controls life-cyles of bean)

                 1.Core Container -BeanFactory based

                 2.Advanced Container -ApplicationContext

                 3.Web Container -WebApplicationContext



                             BeanFactory (I)  -Core Container
                                 |
                                 |XMLBeanFactory (C) :Lazy Initialization
                                 |
                            ApplicationContext(I)    :Eager Initialization  -Advanced Container
                                 |
ClasspathXMLApplicationContext (C)|    AnnotationConfigApplicationContext (C)
                                 |
                                 |
                           ServletWebApplicationContext(I)           


//core container


Lazy Initiialization

XmlBeanFactory c=new XmlBeanFactory(new ClassPathResource("beans.xml"));
         
         
//advanced container
Eager Initialization 
    
ClassPathXmlApplicationContext c=new ClassPathXmlApplicationContext("beans.xml");
	    

<beans default-lazy-init=false|true/>
	    
<bean lazy-init=false|true/>


        
1.get bean by type if only one bean of specific type
  
  CustomerMainApp cma=c.getBean(CustomerMainApp.class);
         
2.get bean by id when multiple beans of same type

CustomerMainApp cma=(CustomerMainApp)c.getBean("customerMainApp");
        




DI :Mechamsim of initialzing the depencencies

  setter   ->    <property name="cs" ref="customerService">

  constructor -> <constructor-arg   name="cs" ref="customerService">
                          
                                                    
Spring Bean Life Cycle
==========================
1.Instantiation
2.Dependency Injection(setter/constructor)
3.Initialization   (init-method)
4.Service
5.Destruction      (destroy-method)


Spring Bean Scope : singleton|prototype|request|session



Spring Bean Scope
==================
<bean  scope="singleton"/>

singleton -Stateless Application
prototype -Stateful Application

request  -web
session  -web


Day3    23-Jun-2021
====================

Auto-wiring
============

Wiring - It's a mechanisam of associating the beans with each other (property or constructor-arg)

Auto-wiring -It's a mechanisam of delegating the responsisbilty of associating the beans with each other to the spring container

auto-wire="no|byType|byName|constructor"




Annotation Based configuration
===============================
                                           @Component
                                               |
                                               |

              @Controller                   @Service                   @Reposiotry



@Configuration   => <beans.xml>
@PostConstruct   => init-method
@PreDestroy      => destroy-method
@Autowire        =>autwire (byType)   can be applied to constructor/setter/interface
@Qualifier       => byName 
@ComponentScan   => <context:component-scan   package="com"/>



<bean> </bean>   :          @Component,@Controller,@Service,@Reposiotory

<bean    init-method=""   destroy-method=""/>    @PostConstruct    @PreDestroy

<bean    autowire=""/>     @Autowire  =>default byType


Note :To enable annotation based bean registration put below tag

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/context
    http://www.springframework.org/schema/context/spring-context.xsd">

<context:component-scan   package="com"/>

</beans>



Day4    23-Jun-2021
===================

CustomerMainApp
              CustomerService
                           CustomerDao
                                        MapCustomerDaoImpl
                                                                                    CustomerMap

                                        MySQLCustomerDaoImpl           
                                                   JdbcTemplate                
                                                         DataSource
                                                               driverClassName       MySQL
                                                               username
                                                               url
                                                               password




add mysqljar file in classpath

mysql-connector-java-8.0.25.jar file  


SQL Script to create database,table and insert the records
============================================================
drop database company;

create database company;

use company;

create table customers(
  customerId int primary key,
  name text,
  pan text,
  mobile text,
  address text,
  dob date
  );

insert into customers values(1111,'Sachin patil','skxnd9834f','8737726736','Pune','1982-01-01');
insert into customers values(2222,'Sumit patil','abcnd9834f','6637726736','Mumbai','1985-01-01');
insert into customers values(3333,'Sunil patil','abcnd9834f','7737726736','Bangalore','1989-01-01');


select * from customers;


JdbcTemplate
==============


GET the Data                   :  List query()
                                  Object  queryForObject()   


UPDATE,INSERT,DELETE           :  int update()

               

RowMapper
==========

public class CustomerRowMapper implements RowMapper<Customer> {

	@Override
	public Customer mapRow(ResultSet rs, int rownum) throws SQLException {

		System.out.println("============In mapRow==========");

		Customer c = new Customer();
		c.setCustomerId(rs.getInt(1));
		c.setName(rs.getNString(2));
		c.setPan(rs.getString(3));
		c.setMobile(rs.getString(4));
		c.setAddress(rs.getString(5));
		c.setDob(rs.getDate(6));

		return c;
	}

}


db.properties
===============
jdbc.driver=com.mysql.cj.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/company
jdbc.username=root
jdbc.password=admin



<!-- Load these values before creating any beans -->

<bean   class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
<property name="location" value="db.properties"/>
</bean>



<!-- DriverManagerDataSource -->
<bean  class="org.springframework.jdbc.datasource.DriverManagerDataSource" id="dataSource">
<property name="driverClassName"   value="${jdbc.driver}"/>
<property name="url"   value="${jdbc.url}"/>
<property name="username"   value="${jdbc.username}"/>
<property name="password"   value="${jdbc.password}"/>
</bean>





Day5    25-Jun-2021
====================

Spring AOP   :Jar file to be added in classpath : aspectjweaver-1.9.6.jar
==========
OOP - Object Oriented Programming

AOP  -Aspect Oriented Programming
=====





Concern :Piece Of Code

                           Functional          Nonfunctional

Business Logic  =          Core Concern    +   Cross Cutting Concern

                            withdraw                  security
                            deposit                   logging 
                            transfer                  scalabilty
                                                      tx mgmt




AOP is used to separate CCC from CC and attach CCC dynamically in a CC.

Can We Separate CCC from CC using OOP? Yes but it is a static approach.
 






//Core Concern
class Banking{


int  withdraw(int accno,double amount){
Logging l=new Logging();
l.print("perform withdrawl");

}


int  deposit(int accno,double amount){
Logging l=new Logging();
l.print("transfer");
}
int  fundTransfer(int source,int destination, double amount){
Logging l=new Logging();
l.print("perform transfer");
}



}


//Cross Cutting
class Logging{

//What to execute
void print(String message){
System.out.println(message)
}

}




Target  :It is a piece of code that implements Core Concern :Banking


Advice  :It is a piece of code that implements Cross Cutting  Concern
               
                 what + when

               before => execute before method
               after  => execute after method execution complete successfully/unsuccessfully
               after return =>execute only after method execution complete successfully
               after throwing=>execute after method throws some exception
               around =>It's a combination of before,after,after return and after throwing

JoinPoint  :
                 It is a well defined point in Core Concern where u want to execute CCC.
                 Spring supports only method call as a join point.

Point Cut  :
                 It is a set of one or more join points
                 

Aspect : advice +point cut  ->what +when+where


Weaving :Mechanism of attaching CCC to CC




What to execute
================

public class Logging {
	
		
	public Logging() {
	System.out.println("Logging Advice created.....");
	}
	
	
	/**
	 * * This is the method which I would like to execute * before a selected
	 * method execution.
	 */
	
	public void beforeAdvice() {
		System.err.println("Going to setup customer profile.");
	}

	/**
	 * * This is the method which I would like to execute * after a selected
	 * method execution.
	 */
	
	public void afterAdvice() {
		System.err.println("Customer profile has been setup.");
	}

	
	
	/**
	 * * This is the method which I would like to execute * when any method
	 * returns.
	 */
    
	public void afterReturningAdvice(Object retVal) {
		System.err.println("Customer afterReturning:" + retVal);
	}

    
	/**
	 * * This is the method which I would like to execute * if there is an
	 * exception raised by any method.
	 */
	
	public void AfterThrowingAdvice(Exception ex) {
		System.err.println("Customer There has been an exception: " + ex);
	}
	

	public Object aroundAdvice(ProceedingJoinPoint joinPoint)throws Throwable{
	
    	Object returnVal=null;
    	System.err.println("In around Advice .....");
    	
    	
    	try {
    		System.err.println("Before Proceed :");
        	returnVal=joinPoint.proceed();
        	System.err.println("After  Proceed :"+returnVal);
        	 Customer value=(Customer)returnVal;
        	
        	 value.setName(value.getName().toUpperCase());   
		    
    	
    	} catch (Throwable e) {
             e.printStackTrace();
         System.out.println("around Advice  exception wrapped.....");
             
    		}
    	System.out.println("around Advice  over.....");
          return returnVal;
    }
    }




When to execute
=================
@Before
@After
@AfterReturn
@AfterThrowing
@Around



Where to Execute
==================
@Pointcut("execution(* com.pradeep.bank.service.CustomerService.*(..))")
private void selectAll() {}

@Pointcut("execution(* com.pradeep.bank.service.CustomerService.findCustomer(..))")
private void select() {}






@Component
@Aspect
public class Logging {
	
	
	
	public Logging() {
	System.out.println("Logging Advice created.....");
	}
	
	/**
	 * Following is the definition for a pointcut to select * all the methods
	 * available. So advice will be called * for all the methods.
	 */
	@Pointcut("execution(* com.pradeep.bank.service.CustomerService.*(..))")
	private void selectAll() {
	}

	@Pointcut("execution(* com.pradeep.bank.service.CustomerService.findCustomer(..))")
	private void select() {
	}

	
	
	/**
	 * * This is the method which I would like to execute * before a selected
	 * method execution.
	 */
	@Before("selectAll()")
	public void beforeAdvice() {
		System.err.println("Going to setup customer profile.");
	}

	/**
	 * * This is the method which I would like to execute * after a selected
	 * method execution.
	 */
	@After("selectAll()")
	public void afterAdvice() {
		System.err.println("Customer profile has been setup.");
	}

	
	
	/**
	 * * This is the method which I would like to execute * when any method
	 * returns.
	 */
    @AfterReturning(pointcut = "selectAll()", returning = "retVal")
	public void afterReturningAdvice(Object retVal) {
		System.err.println("Customer afterReturning:" + retVal);
	}

    
	/**
	 * * This is the method which I would like to execute * if there is an
	 * exception raised by any method.
	 */
	@AfterThrowing(pointcut = "selectAll()", throwing = "ex")
	public void AfterThrowingAdvice(Exception ex) {
		System.err.println("Customer There has been an exception: " + ex);
	}
	

    @Around("select()")
	public Object aroundAdvice(ProceedingJoinPoint joinPoint)throws Throwable{
	
    	Object returnVal=null;
    	System.err.println("In around Advice .....");
    	
    	
    	try {
    		System.err.println("Before Proceed :");
        	returnVal=joinPoint.proceed();
        	System.err.println("After  Proceed :"+returnVal);
        	 Customer value=(Customer)returnVal;
        	
        	 value.setName(value.getName().toUpperCase());   
		    
    	
    	} catch (Throwable e) {
             e.printStackTrace();
         System.out.println("around Advice  exception wrapped.....");
             
    		}
    	System.out.println("around Advice  over.....");
          return returnVal;
    }
    }



To enable Annotation based AOP
==================================
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:context="http://www.springframework.org/schema/context"
	default-lazy-init="true"
	xmlns:aop="http://www.springframework.org/schema/aop"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd
		http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.3.xsd">


<aop:aspectj-autoproxy/>


</beans>




Day6  28-Jun-2021
=================
1.Transaction using Spring Annotation
2.Spring Web MVC

@Transactional

Transaction : It's a interaction with database (DML:INSERT,UPDATE,DELETE)
              It is a group of statements that should be excuteted as single unit successfuly/Unsuccessfully    

JDBC : Connection is by default in autocommit enabled mode.

                         withdraw(int source,double amount)  

   fundTransfer

                         deposit(int destination,double amount)




Spring Web MVC
=================


http://localhost:8080/spring-web-mvc-cms/spring/hello
http://localhost:8080/spring-web-mvc-cms/spring/welcome
http://localhost:8080/spring-web-mvc-cms/spring/greet
http://localhost:8080/spring-web-mvc-cms/spring/today



1.Tomcat Download :https://apachemirror.wuchna.com/tomcat/tomcat-9/v9.0.46/bin/apache-tomcat-9.0.46.zip

2.Add Spring jar file to Tomcat lib directory

3.Create a dynamic web project with web.xml

4.Register a DispatcherServlet in web.xml as below

<servlet>
<servlet-name>spring</servlet-name>
<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
<load-on-startup>1</load-on-startup>
</servlet>

<servlet-mapping>
<servlet-name>spring</servlet-name>
<url-pattern>/spring/*</url-pattern>
</servlet-mapping>

5.By default DispatcherServlet will load the file with name (DispatcherServletName-serlvet.xml) 
  So create a file spring-servlet.xml

6.Create a Root Web application Context
   by default it will search applicationContext.xml
  

<listener>
<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
</listener>


<context-param>
<param-name>contextConfigLocation</param-name>
<param-value>/WEB-INF/applicationContext.xml</param-value>
</context-param>

1.RootWebApplication created first





Spring Web MVC
==============
Develop a Spring Web MVC application to build RESTful Web API to perform CRUD Operations


URI                      METHOD                           OPERATION
============================================================== 

/customers               GET                               GET ALL CUSTOMERS
/customers/1             GET                               GET CUSTOMER BY ID
/customers/1             PUT                               UPDATE CUSTOMER BY ID
/customers/1             DELETE                            DELETE CUSTOMER BY ID
/customers               POST                              ADD CUSTOMER 


HTTP status codes
======================
200    :   OK
201    :   Created
500    :   INTERNAL SERVER ERROR
404    :   NOT FOUND
204    :   NO CONTENT
401    :   INVALID CREDENTAILS
403    :   FORBIDDEN
405    :   METHOD NOT ALLOWED


MVC (                 Model                   View                   Controller)
================================================================================
JSP Model-1          Java Bean                JSP                     JSP
JSP Model-2          Java Bean                JSP                     Servlet    (Struts1.x,JSF 1.x,2.x ,Spring Web MVC)
JSP Model-3          Java Bean                JSP                     Filter     (Struts2.x)
JSP Model-4          Java Bean                JSP                     Tag Handler


Spring Web MVC follows MVC2 /JSP Model2
==============================================   

 url      method      mapping                                                         new style                                         =========================================================================================================



/hello   GET         @RequestMapping(value="/hello",method=RequestMethod.GET)        @GetMapping("/hello")
/hello   POST        @RequestMapping(value="/hello",method=RequestMethod.POST)       @PostMapping("/hello")
/hello   DELETE      @RequestMapping(value="/hello",method=RequestMethod.DELETE)     @DeleteMapping("/hello")
/hello   PUT         @RequestMapping(value="/hello",method=RequestMethod.PUT)        @PutMapping("/hello")
/hello   PATCH       @RequestMapping(value="/hello",method=RequestMethod.PATCH)      @PatchMapping("/hello")




@RestController   =>  @Controller +  @ResponseBody 



<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:mvc="http://www.springframework.org/schema/mvc"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/mvc
        http://www.springframework.org/schema/mvc/spring-mvc.xsd">

    <mvc:annotation-driven/>
</beans>
 


Java To JSON    : @ResponseBody

JSON to Java    : @RequestBody
================================


@ResponseBody  => Server to Client => Java Object to JSON or XML  => Accept       = application/json 

@RequestBody  => Client to Server =>  JSON or XML to Java Object   => Content-Type = application/json


@ResponseBody  => Server to Client => Java Object to JSON or XML  => Accept       = application/json 

@RequestBody  => Client to Server =>  JSON or XML Java Object to  => Content-Type = application/json


For Message Conversion :

Step 1:  add below tag in spring-config file
=======
<mvc:annotation-driven/>

Step 2:  Add below jars in class path
=======
jackson-core-2.9.8
jackson-annotations-2.9.8.jar
jackson-databind-2.9.8.jar

https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core/2.9.8
https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-annotations/2.9.8
https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind/2.9.8





http://localhost:8080/spring-web-mvc-cms/spring/*
http://localhost:8080/spring-web-mvc-cms/rest/*




/spring/*   spring-ds    Controller        Service              Dao/Repository (mySQL)

/rest/*     rest-ds      Controller        Service              Dao/Repository (map)

      



http://localhost:8080/spring-web-mvc-cms/spring/getallcustomers
http://localhost:8080/spring-web-mvc-cms/rest/customers
http://localhost:8080/spring-web-mvc-cms/rest/customers/101








